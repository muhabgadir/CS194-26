<?xml version="1.0" encoding="utf-8"?>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-06 Wed 13:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Final Project</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="*Guilherme Gomes Haetinger* Guilherme Gomes Haetinger@@html:&lt;br /&gt;@@@@html:&lt;br /&gt;@@ University of California, Berkeley @@html:&lt;br /&gt;@@ CS194-26: Image Manipulation and Computational Photography" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style>pre.src{background:#343131;color:white;} </style>
<style> .equation { vertical-align: middle; display: flex; justify-content: center; } .equation p {width: 30%;} .right {float: right} .lineup img {width: 25%}</style>
<style>img { width: 30%; } .stack img { width: 100%; } .GIF img { width: 50% } </style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Final Project</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb38c60a">1. Introduction</a></li>
<li><a href="#orgab8491b">2. Poor Man&rsquo;s AR</a>
<ul>
<li><a href="#org105ca77">2.1. Taking the Video</a></li>
<li><a href="#org3f27feb">2.2. Capturing the Points</a>
<ul>
<li><a href="#orgc1ab120">2.2.1. Input Points</a></li>
<li><a href="#org309f30c">2.2.2. Input World Coordinates</a></li>
<li><a href="#org56a7762">2.2.3. Track points</a></li>
</ul>
</li>
<li><a href="#org4bbb26f">2.3. Calculating the Projection Matrix</a></li>
<li><a href="#org662f4c0">2.4. Drawing a Cube!</a></li>
<li><a href="#org38513bc">2.5. Final Thoughts</a></li>
</ul>
</li>
<li><a href="#org5623972">3. Seam Carving</a>
<ul>
<li><a href="#org226ecba">3.1. Energy Maps</a>
<ul>
<li><a href="#org49757e5">3.1.1. Gradient</a></li>
<li><a href="#org1014d76">3.1.2. Gaussian Gradient</a></li>
<li><a href="#org48c3fad">3.1.3. HoG (Histogram of Gradients)</a></li>
<li><a href="#org22d9daa">3.1.4. HoG + Gaussian Kernel</a></li>
<li><a href="#org05fa6c1">3.1.5. Scharr Kernel</a></li>
<li><a href="#org82915da">3.1.6. Scharr + Gaussian Kernel</a></li>
<li><a href="#orga0c1062">3.1.7. My Function</a></li>
</ul>
</li>
<li><a href="#org9b98898">3.2. Calculating Seams</a></li>
<li><a href="#orgcf0bfee">3.3. Removing Seams</a></li>
<li><a href="#org11b8326">3.4. Efficiently Removing Seams</a></li>
<li><a href="#org93c1595">3.5. Optimizing Energy to Images</a></li>
<li><a href="#org116d112">3.6. User Interface</a></li>
<li><a href="#org2a5188c">3.7. Results</a>
<ul>
<li><a href="#orgbde1000">3.7.1. Good Results</a></li>
<li><a href="#org491be4b">3.7.2. Bad Results &amp; Pragmatic Mitigation</a></li>
</ul>
</li>
<li><a href="#org24e4ca3">3.8. Final Thoughts</a></li>
</ul>
</li>
<li><a href="#org5c58875">4. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb38c60a" class="outline-2">
<h2 id="orgb38c60a"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
The semester has come to an end. I learned a lot by taking <code>CS194-26</code> a.k.a. <code>Computational Photography</code> at <b>UC Berkeley</b>. To finish this class and my stay in Berkeley, I got to pick 2 projects out of some pre-canned project Porf. Efros and the TA&rsquo;s assembled. My decision was to implement both the <i>Poor Man&rsquo;s AR</i> and the <i>Seam Carving</i> projects.<br />
</p>

<hr />
</div>
</div>
<div id="outline-container-orgab8491b" class="outline-2">
<h2 id="orgab8491b"><span class="section-number-2">2</span> Poor Man&rsquo;s AR</h2>
<div class="outline-text-2" id="text-2">
<p>
This project was somewhat similar to the Panorama stitching project in the sense that we need to rely on the computer to find certain edges and their correspondences on different images/frames. The goal is to take a video of a shoe box that has a drawn 3D grid on top of it, set the points manually for the first frame and let the computer do the rest. I enjoyed it even though the results are definitely not as good as regular Augmented Reality you can get on phones today (both efficiency-wise and visualization-wise). This is definitely a <i>Poor Man&rsquo;s AR</i>.<br />
</p>
</div>

<div id="outline-container-org105ca77" class="outline-3">
<h3 id="org105ca77"><span class="section-number-3">2.1</span> Taking the Video</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The first step to creating an Augmented Reality video is to make sure your object has a visible and well defined grid on top/on the side of it. I drew my points and grid on a shoe box I had lying around in my place. The final video looks like this:<br />
</p>


<div class="figure">
<p><img src="./PoorManAR/AR3.gif" alt="AR3.gif" /><br />
</p>
</div>

<p>
You can see I made the points in the grid larger than I should. This is due to a number of problems I had trying to use other objects in which I drew less noticeable dots in the next section.<br />
</p>
</div>
</div>

<div id="outline-container-org3f27feb" class="outline-3">
<h3 id="org3f27feb"><span class="section-number-3">2.2</span> Capturing the Points</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Now, we need to capture the points, i. e. make sure we have the points camera coordinates and world coordinates for each of the frames. To do that, we follow these steps:<br />
</p>
</div>

<div id="outline-container-orgc1ab120" class="outline-4">
<h4 id="orgc1ab120"><span class="section-number-4">2.2.1</span> Input Points</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
We input all the points camera coordinates for the first frame.<br />
</p>


<div class="figure">
<p><img src="./PoorManAR/track.jpg" alt="track.jpg" /><br />
</p>
</div>

<p>
Once this is done, we are ready to track them over the next frames, but we don&rsquo;t know where they are in the world space. Hence, the step that follows.<br />
</p>
</div>
</div>

<div id="outline-container-org309f30c" class="outline-4">
<h4 id="org309f30c"><span class="section-number-4">2.2.2</span> Input World Coordinates</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Alongside the camera coordinates, we also need the world coordinates, i. e. the coordinates inside the box grid, as the following image shows:<br />
</p>


<div class="figure">
<p><img src="./PoorManAR/track_world.jpg" alt="track_world.jpg" /><br />
</p>
</div>

<p>
This will enable us to assign the same world coordinates throughout the frames, making the future projection stable.<br />
</p>
</div>
</div>

<div id="outline-container-org56a7762" class="outline-4">
<h4 id="org56a7762"><span class="section-number-4">2.2.3</span> Track points</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
This part was definitely the hardest part. Considering that I decided to use some tracking algorithms from <code>OpenCV</code> without having any prior knowledge in them, I had to program using it as a &ldquo;Black Box&rdquo; API. The class&rsquo;s facilitators recommended the use of the <code>MedianFlow Tracker</code>, which has good characteristics to represent things that don&rsquo;t really move in their own, but the camera moves around them. However fast this method was, it didn&rsquo;t give me good results for any of the videos I recorded, either by missing a point after some time or just by representing the inaccurately. Therefore, I ended up choosing a more inefficient bu highly accurate method: the <code>CSRT Tracker</code>. This method better tracks non rectangular shapes (we are tracking small round points) and enlarges the selected tracking region. It uses HoG (Histogram of Gradient) and Colornames as its standard features [1].<br />
</p>

<p>
By the end of the tracking phase, we had all the needed coordinates as this video shows:\<br />
</p>


<div class="figure">
<p><img src="./PoorManAR/tracking.gif" alt="tracking.gif" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org4bbb26f" class="outline-3">
<h3 id="org4bbb26f"><span class="section-number-3">2.3</span> Calculating the Projection Matrix</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Now, for us to render points from the world coordinate, we need a transformation matrix \(world_{4x1} \to camera_{3x1}\) (using homogeneous coordinates). We know that this transformation is of the highest degree, meaning it&rsquo;s not an Affine matrix like the face morphing project but a Projection matrix with 8 degrees of freedom. The math follows as we want to solve \(Ax = b\) for A:<br />
</p>

<div class="org-center">
<p>
\(Ax = b \to (Ax)^{T} = b^{T} \to x^{T}A^{T} = b^{T}\)<br />
</p>
</div>

<p>
Which leads us to solving this equation for the least squared points, since we have more than the expected amount of coordinates.<br />
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #f8f8f2;">A</span> = np.linalg.lstsq(x.T, b.T).T
</pre>
</div>

<p>
We do this for every frame to map the world position to the perceived camera position.<br />
</p>
</div>
</div>

<div id="outline-container-org662f4c0" class="outline-3">
<h3 id="org662f4c0"><span class="section-number-3">2.4</span> Drawing a Cube!</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Now that we have this, we can simply map every point of a cube from the world position to their rendered camera position for every frame. I redered a cube with vertex positions [[1,2,0], [1,2,1], [2,2,1], [2,2,0],<br />
[1,3,0],[1,3,1],[2,3,1],[2,3,0]] and it turned out like this:<br />
</p>


<div class="figure">
<p><img src="./PoorManAR/geom.gif" alt="geom.gif" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org38513bc" class="outline-3">
<h3 id="org38513bc"><span class="section-number-3">2.5</span> Final Thoughts</h3>
<div class="outline-text-3" id="text-2-5">
<p>
This was a fun activity I was able to do in one day. I want to try implement in the future a coordinate automatic perceiver with corner detection for the first frame in order to decrease user input. This makes me want to go deeper into AR because even though it was somewhat hard to do in a day, I feel like true AR has so many challenges that I haven&rsquo;t even started to consider for this project.<br />
</p>

<hr />
</div>
</div>
</div>
<div id="outline-container-org5623972" class="outline-2">
<h2 id="org5623972"><span class="section-number-2">3</span> Seam Carving</h2>
<div class="outline-text-2" id="text-3">
<p>
Seam Carving is a technique for resizing context aware windows. In other words, when you change the resolution of some application you have opened, you would rather it fit every object it had inside the window with the same scale but with different accommodations between the objects than it just scale everything down. One example of this technique is shown in webpages with a lot of text like <i>Wikipedia</i>, where the images accommodate the text between them regarding the window scale. The idea of this project is to apply this technique to images. All of it is based on this <a href="https://inst.eecs.berkeley.edu/~cs194-26/fa18/hw/proj4-seamcarving/imret.pdf">paper</a>. Some other examples of Seam Carving and the execution of the algorithm the author&rsquo;s of the paper made can be seen in this <a href="http://www.youtube.com/watch?v=6NcIJXTlugc">video</a>.<br />
</p>

<p>
In summary, this algorithm bases itself on energy functions which we can apply to an image. Once we have this applied, we find the minimal seam (trace of points between one edge and another) and remove it. We do that until we have the resolution we want. All of this will be explained in the next sections.<br />
</p>
</div>

<div id="outline-container-org226ecba" class="outline-3">
<h3 id="org226ecba"><span class="section-number-3">3.1</span> Energy Maps</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Energy functions have the sole purpose of expressing a pixel&rsquo;s importance to the image composition. This is a crucial part of the problem, since the seams importance depend solely o this. I&rsquo;ve come up with 7 different energy functions, for which I map every pixel in the image. I normalize every energy map to the interval \([0, 1]\).<br />
</p>

<p>
The examples will be based on this image:<br />
</p>



<div class="figure">
<p><img src="./SeamCarving/from_paper.png" alt="from_paper.png" /><br />
</p>
</div>
</div>

<div id="outline-container-org49757e5" class="outline-4">
<h4 id="org49757e5"><span class="section-number-4">3.1.1</span> Gradient</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
A simple Sobel gradient function that sums the absolute derivative of the axis: \(energy = |\frac{\partial(I)}{\partial x}| + |\frac{\partial(I)}{\partial y}|\). This was recommended by the paper.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/Grad.png" alt="Grad.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org1014d76" class="outline-4">
<h4 id="org1014d76"><span class="section-number-4">3.1.2</span> Gaussian Gradient</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The same as above but with a Gaussian kernel applied to it. The kernel size is inputted by the user, but usually I prefer the results when the size equals 3~5.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/Gauss.png" alt="Gauss.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org48c3fad" class="outline-4">
<h4 id="org48c3fad"><span class="section-number-4">3.1.3</span> HoG (Histogram of Gradients)</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
This was also used in the paper and is defined by the following equation: \(energy = \frac{|\frac{\partial(I)}{\partial x}| + |\frac{\partial(I)}{\partial y}|}{HoG(I)}\), where \(HoG\) is the Histogram of Gradients.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/HoG.png" alt="HoG.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org22d9daa" class="outline-4">
<h4 id="org22d9daa"><span class="section-number-4">3.1.4</span> HoG + Gaussian Kernel</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
The name is pretty self-explanatory, but it&rsquo;s the HoG function with a Gaussian kernel applied to it.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/HoGauss.png" alt="HoGauss.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org05fa6c1" class="outline-4">
<h4 id="org05fa6c1"><span class="section-number-4">3.1.5</span> Scharr Kernel</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
Instead of a Sobel kernel, we use a Scharr kernel to compute gradients, it&rsquo;s a more intense operation that produces more defined objects.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/Scharr.png" alt="Scharr.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-org82915da" class="outline-4">
<h4 id="org82915da"><span class="section-number-4">3.1.6</span> Scharr + Gaussian Kernel</h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
Again: self-explanatory name. Scharr processed image with a Gaussian kernel applied to it.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/ScharrGauss.png" alt="ScharrGauss.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orga0c1062" class="outline-4">
<h4 id="orga0c1062"><span class="section-number-4">3.1.7</span> My Function</h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
I decided to cook up a function of my own as we were encouraged to. I took one of the energy functions listed down as a Bells and Whistles problem for the Carnegie Mellon University students in their project spec for Seam Carving [3] and mixed them with the Gradient function. Their function took into consideration the first and the second degree gradient. The equation goes like this: \(energy = |\frac{\partial(I)}{\partial x}| + |\frac{\partial(I)}{\partial y}|, finalEnergy = energy + |\frac{\partial(energy)}{\partial x}| + |\frac{\partial(energy)}{\partial y}|\). I also apply a Gaussian filter to it.<br />
</p>


<div class="figure">
<p><img src="./SeamCarving/My.png" alt="My.png" /><br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org9b98898" class="outline-3">
<h3 id="org9b98898"><span class="section-number-3">3.2</span> Calculating Seams</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The seams are calculated by going through the image and summing up the minimal energy paths. If we want to remove a vertical seam (decrease width), we perform a row-wise execution, while if we want to remove a horizontal seam (decrease height), we perform it column-wise. For each pixel in the image, we sum their energy to the minimal seam value between the previous 3 points (previous row for vertical seams and previous column for horizontal seams). By the end of this process, we&rsquo;ll have our seam map as an image such as this:<br />
</p>

<div class="org-center">
<p>
<img src="./SeamCarving/HoG.png" alt="HoG.png" /> &rarr; <img src="./SeamCarving/seams.png" alt="seams.png" /><br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf0bfee" class="outline-3">
<h3 id="orgcf0bfee"><span class="section-number-3">3.3</span> Removing Seams</h3>
<div class="outline-text-3" id="text-3-3">
<p>
By performing a backtrack search from the minimal seam map value in the last edge (lower edge if we want the vertical seam and right edge if we want the horizontal seam), we can find the minimal seam. E. g.:<br />
</p>

<div class="org-center">
<p>
<img src="./SeamCarving/VertSeam.png" alt="VertSeam.png" /> <img src="./SeamCarving/HorSeam.png" alt="HorSeam.png" /><br />
</p>
</div>

<p>
By performing this operation a number of times, we can find the best removable areas (I&rsquo;m using the HoG energy function here):<br />
</p>

<div class="org-center">
<p>
<img src="./SeamCarving/VertSeams.png" alt="VertSeams.png" /> <img src="./SeamCarving/HorSeams.png" alt="HorSeams.png" /><br />
</p>
</div>

<p>
Finally, removing them, gives us the following treamed result:<br />
</p>

<div class="org-center">
<p>
<img src="./SeamCarving/from_paper.png" alt="from_paper.png" /> &rarr; <img src="./SeamCarving/carvedBeach.png" alt="carvedBeach.png" /><br />
</p>
</div>

<p>
Drastically carving the image results in this:<br />
</p>

<div class="org-center">
<p>
<img src="./SeamCarving/from_paper.png" alt="from_paper.png" /> &rarr; <img src="./SeamCarving/drasticBadTrim.png" alt="drasticBadTrim.png" /><br />
</p>
</div>

<p>
We can see that the result looks weird and a little bit rough around the edges. This is due to the fact that HoG is not very compatible with this image. We&rsquo;ll talk about this in the &ldquo;Optimizing Energy to Images&rdquo; section.<br />
</p>
</div>
</div>

<div id="outline-container-org11b8326" class="outline-3">
<h3 id="org11b8326"><span class="section-number-3">3.4</span> Efficiently Removing Seams</h3>
<div class="outline-text-3" id="text-3-4">
<p>
One of my goals with this project was to create a cool UI for people to be able to downsize their images with seam carving. However, waiting for the seam map to be calculated every time you want to remove one seam takes a lot of processing power and renders the possibility of making a real-time interaction interface almost impossible. This is why I decided to separate what could be precomputed and what couldn&rsquo;t. The energy map and the seam map could definitely be precomputed. The seams could be precomputed as well, but you could be removing one of the seams pixels when removing another one, making a hard to filter edge-case. Once I had those, all I needed was to find the minimum value at the end edge and backtrack every time I wanted to trim the seam of an image. However, this stucks with images of resolution less than 500x500 since my own backtracking algorithm could use a bit of an efficiency boost. But here we have a real-time interface interaction:<br />
</p>

<div class="GIF">

<div class="figure">
<p><img src="./SeamCarving/fast.gif" alt="fast.gif" /><br />
</p>
</div>

</div>
</div>
</div>

<div id="outline-container-org93c1595" class="outline-3">
<h3 id="org93c1595"><span class="section-number-3">3.5</span> Optimizing Energy to Images</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Another possibility of Bells and Whistles for this project was to project a heuristic that would find the best energy map for a given image. As I said before, not all images have a &ldquo;best energy function&rdquo; and this is even acknowledged on the paper I based myself on. Therefore, I designed the following heuristic: the better the energy function, the closer to the center of the image the position mean will be. As an example, we have the following images and their heuristic orderings:<br />
</p>

<div class="org-center">
<p>
<img src="./SeamCarving/2ndBestTrimSeams.png" alt="2ndBestTrimSeams.png" /> &lt; <img src="./SeamCarving/GoodTrimHeurSeams.png" alt="GoodTrimHeurSeams.png" /><br />
<img src="./SeamCarving/2ndBestTrim.png" alt="2ndBestTrim.png" /> &lt; <img src="./SeamCarving/GoodTrimHeur.png" alt="GoodTrimHeur.png" /><br />
</p>
</div>

<p>
For these results, I used N = 100.<br />
</p>

<p>
We can see how the 2nd best energy function tricks the heuristic by having a highly concentrated seam cluster but alternating the minimal seams between the cluster endpoints. The best ouput (right) is clearly the best trim. It maintains the right sea view and the regular cloud forms. I have also tried another heuristic which states that the best energy map is the one whose seam position mean is closer to the center, but then we could still have concentrated clusters.<br />
</p>
</div>
</div>

<div id="outline-container-org116d112" class="outline-3">
<h3 id="org116d112"><span class="section-number-3">3.6</span> User Interface</h3>
<div class="outline-text-3" id="text-3-6">
<p>
I created a user interface which enables you to see the energy map, seam map, trim the image in real time and plot whatever map you see. Once I had this interface, I was able to debug the program much more easily. Here is a demo:<br />
</p>

<div class="GIF">

<div class="figure">
<p><img src="./SeamCarving/UI.gif" alt="UI.gif" /><br />
</p>
</div>

</div>
</div>
</div>

<div id="outline-container-org2a5188c" class="outline-3">
<h3 id="org2a5188c"><span class="section-number-3">3.7</span> Results</h3>
<div class="outline-text-3" id="text-3-7">
<p>
I got some really good results for landscape images. However, I had some problems when seams got really concentrated. I will show both in two separate sections (I used my heuristic in all the results + gauss kernel of size 5 when the returned heuristic used it). The heuristic didn&rsquo;t seem to like my energy function, so I added its result as well (in my opinion they were the best).<br />
</p>
</div>

<div id="outline-container-orgbde1000" class="outline-4">
<h4 id="orgbde1000"><span class="section-number-4">3.7.1</span> Good Results</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
Format: first = original, second = heuristic energy resized, third (bottom) = my energy function resized<br />
</p>
</div>
<ol class="org-ol">
<li><a id="orgd1b3005"></a>Lake image<br />
<div class="outline-text-5" id="text-3-7-1-1">
<p>
Picked energy: Gaussian Gradient.<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/from_paper2.png" alt="from_paper2.png" /> &rarr; <img src="./SeamCarving/from_paper2res.png" alt="from_paper2res.png" /><br />
&rarr; <img src="./SeamCarving/myfrom_paper2.png" alt="myfrom_paper2.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="org52808af"></a>Tree<br />
<div class="outline-text-5" id="text-3-7-1-2">
<p>
Picked energy: Gradient.<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/tree.jpeg" alt="tree.jpeg" /> &rarr; <img src="./SeamCarving/treeres.png" alt="treeres.png" /><br />
&rarr; <img src="./SeamCarving/mytree.png" alt="mytree.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="orgc521a16"></a>Sacramento<br />
<div class="outline-text-5" id="text-3-7-1-3">
<p>
Picked energy: My energy (this one I&rsquo;ll only show 2 results)<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/sacr2.jpg" alt="sacr2.jpg" /> &rarr; <img src="./SeamCarving/sacr2res.png" alt="sacr2res.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="orgb70cf20"></a>Panel<br />
<div class="outline-text-5" id="text-3-7-1-4">
<p>
Picked energy: HoG + Gauss.<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/web.png" alt="web.png" /> &rarr; <img src="./SeamCarving/web2.png" alt="web2.png" /><br />
&rarr; <img src="./SeamCarving/myweb.png" alt="myweb.png" /><br />
</p>
</div>
</div>
</li>

<li><a id="org81f5a8b"></a>Panorama Trees<br />
<div class="outline-text-5" id="text-3-7-1-5">
<p>
Picked energy: Scharr + Gauss.<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/panorama.jpeg" alt="panorama.jpeg" /> &rarr; <img src="./SeamCarving/panores.png" alt="panores.png" /><br />
&rarr; <img src="./SeamCarving/mypano.png" alt="mypano.png" /><br />
</p>
</div>
</div>
</li>
</ol>
</div>

<div id="outline-container-org491be4b" class="outline-4">
<h4 id="org491be4b"><span class="section-number-4">3.7.2</span> Bad Results &amp; Pragmatic Mitigation</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
These bad results are due to the fact that my seams were highly concentrated on them. My proposed mitigation will be applied in the 3rd image (bottom). The mitigation is to spread the minimal seam&rsquo;s value to a given rate to the 2 adjacent seams. This way, it will decrease the chances of removing everything from the concentration area. This gives out some good results but it also changes the seams, sometimes bending the image to extremes. I used a spread rate of <code>0.2</code> in the following results.<br />
</p>
</div>

<ol class="org-ol">
<li><a id="org9199310"></a>Cabin<br />
<div class="outline-text-5" id="text-3-7-2-1">
<p>
Picked energy: My energy<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/cabin.jpg" alt="cabin.jpg" /> &rarr; <img src="./SeamCarving/badCabin.png" alt="badCabin.png" /><br />
&rarr; <img src="./SeamCarving/spreadCabin.png" alt="spreadCabin.png" /><br />
</p>
</div>

<p>
We see it removed the right tree completely when it shouldn&rsquo;t! In the one in which I use my spread algorithm, the tree stays, but the picture is sort of inconsistent.<br />
</p>
</div>
</li>

<li><a id="orgc61e3f6"></a>Couch<br />
<div class="outline-text-5" id="text-3-7-2-2">
<p>
Picked energy: My energy<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/couch.jpg" alt="couch.jpg" /> &rarr; <img src="./SeamCarving/badcouch.png" alt="badcouch.png" /><br />
&rarr; <img src="./SeamCarving/spreadCouch.png" alt="spreadCouch.png" /><br />
</p>
</div>

<p>
We can see how the regular result just ignores the couch completely while the spread algorithm result takes it into consideration! (It&rsquo;s still bendy and inconsistent though).<br />
</p>
</div>
</li>

<li><a id="org3e13e8d"></a>Sunset Arch<br />
<div class="outline-text-5" id="text-3-7-2-3">
<p>
Picked energy: Scharr + Gauss<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/arch_sunset.jpg" alt="arch_sunset.jpg" /> &rarr; <img src="./SeamCarving/badarch.png" alt="badarch.png" /><br />
&rarr; <img src="./SeamCarving/spreadArch.png" alt="spreadArch.png" /><br />
</p>
</div>

<p>
Now this one only has bad results. The horizontal seams, even with the spread algorithm concentrates on trimming the lake while it should trim above the arch!<br />
</p>
</div>
</li>

<li><a id="org9c1123d"></a>Shirtless Guy<br />
<div class="outline-text-5" id="text-3-7-2-4">
<p>
Picked energy: My energy<br />
</p>
<div class="org-center">
<p>
<img src="./SeamCarving/guy.jpg" alt="guy.jpg" /> &rarr; <img src="./SeamCarving/badguy.png" alt="badguy.png" /><br />
&rarr; <img src="./SeamCarving/spreadGuy.png" alt="spreadGuy.png" /><br />
</p>
</div>

<p>
Again: only has bad results. Using faces is definitely hard with this! (The spread one looks funny).<br />
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org24e4ca3" class="outline-3">
<h3 id="org24e4ca3"><span class="section-number-3">3.8</span> Final Thoughts</h3>
<div class="outline-text-3" id="text-3-8">
<p>
Honestly, implementing this was both really fun and painful. Whenever I thought my algorithm was wrong, I tried another energy function and it worked nice. It&rsquo;s really hard to debug when you don&rsquo;t know if the problem is in your code or on the picture compatibility with your energy function. I liked the results and learned a lot though. I still want to make this more efficient and with less <code>for</code> loops as Prof. Efros hates them.<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org5c58875" class="outline-2">
<h2 id="org5c58875"><span class="section-number-2">4</span> References</h2>
<div class="outline-text-2" id="text-4">
<p>
[1]<a href="https://www.learnopencv.com/object-tracking-using-opencv-cpp-python/">OpenCV Tracking Tutorial</a><br />
[2]<a href="http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/f07/proj2/www/wwedler/">CMU Seam Carving Project Specification</a><br />
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: <b>Guilherme Gomes Haetinger</b> <br /><br /> University of California, Berkeley <br /> CS194-26: Image Manipulation and Computational Photography</p>
<p class="date">Created: 2020-05-06 Wed 13:43</p>
</div>
</body>
</html>
