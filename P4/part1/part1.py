# -*- coding: utf-8 -*-
"""HW4-CS194

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R5uk8sSJvi8qNMNi8o6UH2VKe3-OnVeV
"""

train = False

import torch
import torchvision
import torchvision.transforms as transforms

transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize([0.5], [0.5])])

trainset = torchvision.datasets.FashionMNIST(root='./data', train=True,
                                        download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=4,
                                          shuffle=True, num_workers=2)

testset = torchvision.datasets.FashionMNIST(root='./data', train=False,
                                        download=True, transform=transform)
testloader = torch.utils.data.DataLoader(trainset, batch_size=4,
                                          shuffle=False, num_workers=2)

classes = list(trainset.class_to_idx.keys())
import matplotlib.pyplot as plt
import numpy as np


def imshow(img):
    img = img / 2 + 0.5
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()

dataiter = iter(trainloader)
images, labels = dataiter.next()

f, axarr = plt.subplots(2, 4)
for j in range(0, 4):
  axarr[0, j].axis("off")
  axarr[0, j].set_title(classes[labels[j]])
  axarr[0, j].imshow(images[j][0])

images, labels = dataiter.next()
for j in range(0, 4):
  axarr[1, j].axis("off")
  axarr[1, j].set_title(classes[labels[j]])
  axarr[1, j].imshow(images[j][0])
plt.show()

import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

class Net(nn.Module):

    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, 5)
        self.conv2 = nn.Conv2d(32, 32, 3)
        self.pool = nn.MaxPool2d(2, 2)
        self.pool2 = nn.MaxPool2d(2, 2)
        self.fc1 = nn.Linear(32 * 5 * 5, 120)
        self.fc2 = nn.Linear(120, 10)


    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool2(F.relu(self.conv2(x)))
        x = x.view(-1, self.num_flat_features(x))
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

    def num_flat_features(self, x):
        size = x.size()[1:]
        num_features = 1
        for s in size:
            num_features *= s
        return num_features

    def plot_filters(self):
        weights_conv1 = self.conv1.weight.data.cpu().numpy()
        weights_conv2 = self.conv2.weight.data.cpu().numpy()
        f, axarr = plt.subplots(8,8)

        for i in range(0, 4):
          for j in range(0, 8):
            axarr[i, j].axis("off")
            axarr[i, j].imshow(weights_conv1[i*8+j][0])
        for i in range(0, 4):
          for j in range(0, 8):
            axarr[i+4, j].axis("off")
            axarr[i+4, j].imshow(weights_conv2[i*8+j][0])
        plt.axis("off")
        plt.show()



net = Net()
net = net.to(device)

criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(),lr=0.01)

if train:
    counter = 0
    mean = 0.0
    while True:
       running_loss = 0.0
       total = 0.0
       num_data = 0
       for i, data in enumerate(trainloader, 0):
           inputs, labels = data[0].to(device), data[1].to(device)

           optimizer.zero_grad()
           outputs = net(inputs)
           loss = criterion(outputs, labels)
           loss.backward()
           optimizer.step()
           running_loss += loss.item()
           total += loss.item()
           num_data += 1
           if i % 2000 == 1999:
               print('[%5d] loss: %.3f' %
                     (i + 1, running_loss / 2000))
               running_loss = 0.0
       new_mean = total / num_data
       if abs(new_mean - mean) < 0.05:
           counter += 1
       else:
           counter = 0
       if counter >= 3:
           break
       mean = new_mean


    print('Finished Training')
    torch.save(net.state_dict(), './new_cloth_net.pth')
else:
    net = Net()
    net.load_state_dict(torch.load('./cloth_net.pth'))
    net = net.to(device)

correct = 0
total = 0
wrong_map = {}
total_map = {}
correct_ls = {}
wrong_ls = {}
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images.to(device))
        _, predicted = torch.max(outputs.data, 1)
        for i in range(labels.size(0)):
          total += 1
          if not classes[labels[i]] in total_map:
            total_map[classes[labels[i]]] = 1
          else:
            total_map[classes[labels[i]]] += 1
          if predicted[i] == labels[i]:
            correct += 1
            if not classes[labels[i]] in correct_ls:
              correct_ls[classes[labels[i]]] = []
            if len(correct_ls[classes[labels[i]]]) < 2:
              correct_ls[classes[labels[i]]].append((images[i], classes[predicted[i]], classes[labels[i]]))
          else:
            if not classes[labels[i]] in wrong_ls:
              wrong_ls[classes[labels[i]]] = []
            if len(wrong_ls[classes[labels[i]]]) < 2:
              wrong_ls[classes[labels[i]]].append((images[i], classes[predicted[i]], classes[labels[i]]))
            if not classes[labels[i]] in wrong_map:
              wrong_map[classes[labels[i]]] = 1
            else:
              wrong_map[classes[labels[i]]] += 1

print('Accuracy of the network in the test database: %d %%' % (
    100 * correct / total))

for cloth in classes:
  print("accuracy for ", cloth, ": ", int(100 * ((total_map[cloth] - wrong_map[cloth])/total_map[cloth])), "%")

net.plot_filters()

print("Correctly predicted clothes: ")

for class_label in correct_ls:
  f, axarr = plt.subplots(1, 2)
  axarr[0].set_title(correct_ls[class_label][0][1])
  axarr[0].imshow(correct_ls[class_label][0][0][0])
  axarr[1].set_title(correct_ls[class_label][1][1])
  axarr[1].imshow(correct_ls[class_label][1][0][0])
  plt.axis("off")
  plt.show()

print("Wrongly predicted clothes: ")

for class_label in correct_ls:
  f, axarr = plt.subplots(1, 2)
  axarr[0].set_title(wrong_ls[class_label][0][1] + "\n (" + wrong_ls[class_label][0][2] + ")")
  axarr[0].imshow(wrong_ls[class_label][0][0][0])
  axarr[1].set_title(wrong_ls[class_label][1][1] + "\n (" + wrong_ls[class_label][1][2] + ")")
  axarr[1].imshow(wrong_ls[class_label][1][0][0])
  plt.axis("off")
  plt.show()

from torch.autograd import Variable
from PIL import Image, ImageOps
image = Image.open("./rsz.jpg")

# Define transformations for the image, should (note that imagenet models are trained with image size 224)
transformation = transforms.Compose([
  transforms.ToTensor(),
  transforms.Normalize([0.5], [0.5])
])

image_tensor = transformation(image).float()
image_tensor = image_tensor.unsqueeze_(0)
if device == "cuda:0":
    image_tensor.cuda()
output = net(Variable(image_tensor).to(device))
_, predicted = torch.max(output.data, 1)

print("Prediction over my photo", classes[predicted])

image = Image.open("./crop_bw_inv.jpg")
image_tensor = transformation(image).float()
image_tensor = image_tensor.unsqueeze_(0)
if device == "cuda:0":
    image_tensor.cuda()
output = net(Variable(image_tensor).to(device))
_, predicted = torch.max(output.data, 1)

print("Prediction over my negative filtered photo: ", classes[predicted])

image = Image.open("./bw_j.jpg")
image_tensor = transformation(image).float()
image_tensor = image_tensor.unsqueeze_(0)
if device == "cuda:0":
    image_tensor.cuda()
output = net(Variable(image_tensor).to(device))
_, predicted = torch.max(output.data, 1)

print("Prediction over my Jacket: ", classes[predicted])
