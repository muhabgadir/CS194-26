# -*- coding: utf-8 -*-
"""part2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kfM2iEbp2c8QZLdEB2IFuRPoYiAMtn-4
"""
import os
import time

import cv2
import matplotlib.pyplot as plt
import numpy as np
import png
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
from colormap.colors import Color, hex2rgb
from sklearn.metrics import average_precision_score as ap_score
from torch.utils.data import DataLoader
from torchvision import datasets, models, transforms
from tqdm import tqdm

from dataset import FacadeDataset

N_CLASS=5

class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.n_class = N_CLASS
        self.layers = nn.Sequential(
            nn.Conv2d(3, 50, 2, padding=0), # 255
            nn.ReLU(inplace=True),
            nn.MaxPool2d(2), # 127
            nn.Conv2d(50, 200, 2, padding=0), # 126
            nn.ReLU(inplace=True),
            nn.MaxPool2d(2), # 63
            nn.Conv2d(200, 1000, 2, padding=0), # 62
            nn.ReLU(inplace=True),
            nn.Conv2d(1000, 2000, 2, padding=0), # 61
            nn.ReLU(inplace=True),
            nn.Conv2d(2000, 4000, 2, padding=0), # 60
            nn.ReLU(inplace=True),
            nn.Conv2d(4000, self.n_class, 2, padding=0), # 59
            nn.ConvTranspose2d(self.n_class, self.n_class, 6, padding=0), #(64)
            nn.Upsample(scale_factor=2*2)
    )

    def forward(self, x):
        x = self.layers(x)
        return x

    def num_flat_features(self, x):
        size = x.size()[1:]
        num_features = 1
        for s in size:
            num_features *= s
        return num_features


def save_label(label, path):
    '''
    Function for ploting labels.
    '''
    colormap = [
        '#000000',
        '#0080FF',
        '#80FF80',
        '#FF8000',
        '#FF0000',
    ]
    assert(np.max(label)<len(colormap))
    colors = [hex2rgb(color, normalise=False) for color in colormap]
    w = png.Writer(label.shape[1], label.shape[0], palette=colors, bitdepth=4)
    with open(path, 'wb') as f:
        w.write(f, label)

train_loss = []
test_loss = []

def train(trainloader, net, criterion, optimizer, device, epoch):
    '''
    Function for training.
    '''
    global train_loss
    start = time.time()
    running_loss = 0.0
    cnt = 0
    net = net.train()
    for images, labels in tqdm(trainloader):
        images = images.to(device)
        labels = labels.to(device)
        optimizer.zero_grad()
        output = net(images)
        loss = criterion(output, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
        cnt += 1
    end = time.time()
    train_loss += [running_loss/cnt]
    print(train_loss)
    print('[epoch %d] loss: %.3f elapsed time %.3f' %
          (epoch, running_loss, end-start))

def test(testloader, net, criterion, device):
    '''
    Function for testing.
    '''
    global test_loss
    losses = 0.
    cnt = 0
    with torch.no_grad():
        net = net.eval()
        for images, labels in tqdm(testloader):
            images = images.to(device)
            labels = labels.to(device)
            output = net(images)
            loss = criterion(output, labels)
            losses += loss.item()
            cnt += 1
    test_loss += [losses/cnt]
    print(test_loss)
    return (losses/cnt)


def cal_AP(testloader, net, criterion, device):
    '''
    Calculate Average Precision
    '''
    losses = 0.
    cnt = 0
    with torch.no_grad():
        net = net.eval()
        preds = [[] for _ in range(5)]
        heatmaps = [[] for _ in range(5)]
        for images, labels in tqdm(testloader):
            images = images.to(device)
            labels = labels.to(device)
            output = net(images).cpu().numpy()
            for c in range(5):
                preds[c].append(output[:, c].reshape(-1))
                heatmaps[c].append(labels[:, c].cpu().numpy().reshape(-1))

        aps = []
        for c in range(5):
            preds[c] = np.concatenate(preds[c])
            heatmaps[c] = np.concatenate(heatmaps[c])
            if heatmaps[c].max() == 0:
                ap = float('nan')
            else:
                ap = ap_score(heatmaps[c], preds[c])
                aps.append(ap)
            print("AP = {}".format(ap))

    return None


def get_result(testloader, net, device, folder='output_train'):
    result = []
    cnt = 1
    with torch.no_grad():
        net = net.eval()
        cnt = 0
        for images, labels in tqdm(testloader):
            images = images.to(device)
            labels = labels.to(device)
            output = net(images)[0].cpu().numpy()
            c, h, w = output.shape
            assert(c == N_CLASS)
            y = np.zeros((h,w)).astype('uint8')
            for i in range(N_CLASS):
                mask = output[i]>0.5
                y[mask] = i
            gt = labels.cpu().data.numpy().squeeze(0).astype('uint8')
            save_label(y, './{}/y{}.png'.format(folder, cnt))
            save_label(gt, './{}/gt{}.png'.format(folder, cnt))
            plt.imsave(
                './{}/x{}.png'.format(folder, cnt),
                ((images[0].cpu().data.numpy()+1)*128).astype(np.uint8).transpose(1,2,0))

            cnt += 1

def main():
    train_bool = True
    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
    train_data = FacadeDataset(flag='train', data_range=(0,114), onehot=False)
    train_loader = DataLoader(train_data, batch_size=10)
    test_data = FacadeDataset(flag='test_dev', data_range=(0,114), onehot=False)
    test_loader = DataLoader(test_data, batch_size=1)
    ap_data = FacadeDataset(flag='test_dev', data_range=(0,114), onehot=True)
    ap_loader = DataLoader(ap_data, batch_size=1)

    name = 'starter_net'
    net = Net().to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = torch.optim.Adam(net.parameters(), 1e-3, weight_decay=1e-5)

    if train_bool:
        print('\nStart training')
        for epoch in range(50):
            print('-----------------Epoch = %d-----------------' % (epoch+1))
            train(train_loader, net, criterion, optimizer, device, epoch+1)
            evaluation_loader = test_loader
            test(evaluation_loader, net, criterion, device)

        print('\nFinished Training, Testing on test set')
        test(test_loader, net, criterion, device)
        print('\nGenerating Unlabeled Result')
        result = get_result(test_loader, net, device, folder='output_test')
        torch.save(net.state_dict(), './models/model_{}.pth'.format(name))
    else:
        net.load_state_dict(torch.load('./models/model_{}.pth'.format(name)))

    cal_AP(ap_loader, net, criterion, device)
    from torch.autograd import Variable
    from PIL import Image

    image = Image.open("./facade.jpg")

    transformation = transforms.Compose([
      transforms.ToTensor(),
      transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
    ])

    image_tensor = transformation(image).float()
    image_tensor = image_tensor.unsqueeze_(0)
    image_tensor.cuda()
    output = net(Variable(image_tensor).to(device))[0].cpu().detach().numpy()
    c, h, w = output.shape
    assert(c == N_CLASS)
    y = np.zeros((h,w)).astype('uint8')
    for i in range(N_CLASS):
      mask = output[i]>0.5
      y[mask] = i
    save_label(y, 'result.png')

    img = Image.open("./result.png")
    oimg = Image.open("./facade.jpg")
    plt.imshow(img)
    plt.show()
    plt.imshow(oimg)
    plt.show()

    plt.plot(train_loss, label="Train")
    plt.plot(test_loss, label="Test")
    plt.title("Train & Test Loss")
    plt.ylabel("Loss")
    plt.xlabel("Epoch")
    plt.legend()
    plt.show()

if __name__ == "__main__":
    main()
